
【编程题】(满分23分)

    俗话说：十赌九输。因为大多数赌局的背后都藏有阴谋。不过也不尽然，有些赌局背后藏有的是：“阳谋”。

    有一种赌局是这样的：桌子上放六个匣子，编号是1至6。多位参与者（以下称玩家）可以把任意数量的钱押在某个编号的匣子上。所有玩家都下注后，庄家同时掷出3个骰子（骰子上的数字都是1至6）。输赢规则如下：

    1. 若某一个骰子上的数字与玩家所押注的匣子号相同，则玩家拿回自己的押注，庄家按他押注的数目赔付（即1比1的赔率）。

    2. 若有两个骰子上的数字与玩家所押注的匣子号相同，则玩家拿回自己的押注，庄家按他押注的数目的2倍赔付（即1比2的赔率）。

    3. 若三个骰子上的数字都与玩家所押注的匣子号相同，则玩家拿回自己的押注，庄家按他押注的数目的6倍赔付（即1比6的赔率）。

    4. 若玩家所押注匣子号与某个骰子示数乘积等于另外两个骰子示数的乘积，则玩家拿回自己的押注，庄家也不赔付（流局）。

    5. 若以上规则有同时满足者，玩家可以选择对自己最有利的规则。规则执行后，则庄家收获所有匣子上剩余的押注。

    乍一看起来，好像规则对玩家有利，庄家吃亏。但经过大量实战，会发现局面很难说，于是怀疑是否庄家做了手脚，庄家则十分爽快地说：可以由玩家提供骰子，甚至也可以由玩家来投掷骰子。

    你的任务是：通过编程模拟该过程。模拟50万次，假定只有1个玩家，他每次的押注都是1元钱，其押注的匣子号是随机的。再假定庄家有足够的资金用于赔付。最后计算出庄家的盈率（庄家盈利金额/押注总金额）。


【输入、输出格式要求】

    程序无输入，程序运行输出庄家的盈率，四舍五入保留到小数后3位。



public class GambleOld {
	static int sum = 0;	// 庄家总钱数
	public static void f(int m,int n,int a,int b,int c){
		//玩家压注号与三个骰子一样，则庄1:6赔
		if(n==a&&n==b&&n==c){
			sum -= 6*m;			
		}else if(n==a&&n==b||n==a&&n==c||n==b&&n==c)
			//玩家压注号与两个骰子一样，则庄1:2赔
		{
			sum -= 2*m;
		}else if(n==a||n==b||n==c){
		//玩家压注号与一个骰子一样，则庄1:1赔
			sum -= m;
		}else if(!(n*a==b*c||n*b==a*c||n*c==a*b)){
			//
			sum += m;
		}
	}
	public static void main(String[] args) throws Exception{
		int m ;	// 押注都是1-10元钱
		int n1;		// 押注匣子号
		int a;		// 第一个骰子
		int b;		// 第二个骰子
		int c;		// 第三个骰子
	  	for(int i=0;i<500000;i++){
			m=(int)(Math.random()*10+1);
			n1 = (int)(Math.random()*6+1);
			a = (int)(Math.random()*6+1);
			b = (int)(Math.random()*6+1);
			c = (int)(Math.random()*6+1);
			f(m,n1,a,b,c);
		}
		double d = sum/500000f;
		System.out.printf("%.3f\n",d);
	  }
}

